import { Component, EventEmitter, Inject, Input, Output } from '@angular/core';
//import { PagedList } from 'src/app/shared/models/paged-list';
import { SelectionModel } from '@angular/cdk/collections';
import { EDITOR } from '../../editor';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/list";
import * as i2 from "@angular/material/paginator";
import * as i3 from "../../editor";
export class PickerEditorComponent {
    constructor(editor) {
        this.editor = editor;
        this.params = {}; // PagedRequest; // TODO: USe it for paging?
        this.changed = new EventEmitter(); // TODO: USe it to update data from outside
        this.pageSize = 10;
    } //,
    // TODO REMOVE private injector: Injector) { }
    ngOnInit() {
        const data = this.editor.config.data;
        this.config = data.config;
        // this.service = this.injector.get<any>(data.config.service);
        this.editor.saved.subscribe(() => this.save());
        this.selection = new SelectionModel(true, this.config.multiple ? data.items : []);
        this.selection.isSelected = this.isChecked.bind(this);
        // TODO this.params = getRequest(this.config?.filters);
        // TODO this.getData();
    }
    /*getData(): void {
      this.service.search(this.params).subscribe((result: PagedList<T>) => {
        this.items = result;
      });
    }*/
    toggle(item) {
        const selected = this.selection.selected.find(x => x.id === item.id);
        if (selected)
            this.selection.deselect(selected);
        else
            this.selection.select(item);
        if (!this.config.multiple)
            this.save();
    }
    save() {
        this.editor.close(this.selection.selected);
    }
    isChecked(item) {
        return this.selection.selected.some(x => x.id === item.id);
    }
    onPageChange(event) {
        this.params.pageNumber = event.pageIndex + 1;
        // this.getData();
        this.changed.emit(this.params);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.0", ngImport: i0, type: PickerEditorComponent, deps: [{ token: EDITOR }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.2.0", type: PickerEditorComponent, selector: "app-picker-editor", inputs: { totalItems: "totalItems", pageSize: "pageSize" }, outputs: { changed: "changed" }, ngImport: i0, template: "<!-- Filters -->\n<!-- // TODO: Add filters... -->\n<!--<app-filters *ngIf=\"config.filters\" [filters]=\"config.filters\" (onFilter)=\"filter($event)\" />-->\n\n<!-- Selection list -->\n@if (items?.length) {\n  <mat-selection-list #picker class=\"mt-2\"\n    [multiple]=\"config.multiple\" [hideSingleSelectionIndicator]=\"true\">\n    <!-- // TODO: Check if the congig.id(item) condition below is correct -->\n    @for (item of items; track item) {\n      <mat-list-option class=\"list-item\" [value]=\"item.id\"\n        [selected]=\"selection.isSelected(item)\" (click)=\"toggle(item)\">\n        <span matListItemTitle>{{ config.name(item) }}</span>\n        @if (config.description) {\n          <span matListItemLine>{{ config.description(item) }}</span>\n        }\n      </mat-list-option>\n    }\n  </mat-selection-list>\n} @else {\n  <div class=\"border rounded p-3 mt-3\">\n    {{ 'Nessun elemento da visualizzare' }} <!-- // TODO: Translate in whole library -->\n  </div>\n}\n\n\n<!-- Pagination -->\n<!-- // TODO: Chnage pagination -->\n@if (items && totalItems && pageSize && totalItems > pageSize) {\n  <mat-paginator [length]=\"totalItems\"\n    [pageSize]=\"pageSize\" [hidePageSize]=\"true\" (page)=\"onPageChange($event)\" showFirstLastButtons />\n}", styles: [".list-item{border-bottom:1px solid #ebedef}\n"], dependencies: [{ kind: "component", type: i1.MatSelectionList, selector: "mat-selection-list", inputs: ["color", "compareWith", "multiple", "hideSingleSelectionIndicator", "disabled"], outputs: ["selectionChange"], exportAs: ["matSelectionList"] }, { kind: "component", type: i1.MatListOption, selector: "mat-list-option", inputs: ["togglePosition", "checkboxPosition", "color", "value", "selected"], outputs: ["selectedChange"], exportAs: ["matListOption"] }, { kind: "directive", type: i1.MatListItemLine, selector: "[matListItemLine]" }, { kind: "directive", type: i1.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "component", type: i2.MatPaginator, selector: "mat-paginator", inputs: ["color", "pageIndex", "length", "pageSize", "pageSizeOptions", "hidePageSize", "showFirstLastButtons", "selectConfig", "disabled"], outputs: ["page"], exportAs: ["matPaginator"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.0", ngImport: i0, type: PickerEditorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-picker-editor', template: "<!-- Filters -->\n<!-- // TODO: Add filters... -->\n<!--<app-filters *ngIf=\"config.filters\" [filters]=\"config.filters\" (onFilter)=\"filter($event)\" />-->\n\n<!-- Selection list -->\n@if (items?.length) {\n  <mat-selection-list #picker class=\"mt-2\"\n    [multiple]=\"config.multiple\" [hideSingleSelectionIndicator]=\"true\">\n    <!-- // TODO: Check if the congig.id(item) condition below is correct -->\n    @for (item of items; track item) {\n      <mat-list-option class=\"list-item\" [value]=\"item.id\"\n        [selected]=\"selection.isSelected(item)\" (click)=\"toggle(item)\">\n        <span matListItemTitle>{{ config.name(item) }}</span>\n        @if (config.description) {\n          <span matListItemLine>{{ config.description(item) }}</span>\n        }\n      </mat-list-option>\n    }\n  </mat-selection-list>\n} @else {\n  <div class=\"border rounded p-3 mt-3\">\n    {{ 'Nessun elemento da visualizzare' }} <!-- // TODO: Translate in whole library -->\n  </div>\n}\n\n\n<!-- Pagination -->\n<!-- // TODO: Chnage pagination -->\n@if (items && totalItems && pageSize && totalItems > pageSize) {\n  <mat-paginator [length]=\"totalItems\"\n    [pageSize]=\"pageSize\" [hidePageSize]=\"true\" (page)=\"onPageChange($event)\" showFirstLastButtons />\n}", styles: [".list-item{border-bottom:1px solid #ebedef}\n"] }]
        }], ctorParameters: () => [{ type: i3.EditorComponent, decorators: [{
                    type: Inject,
                    args: [EDITOR]
                }] }], propDecorators: { changed: [{
                type: Output
            }], totalItems: [{
                type: Input
            }], pageSize: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlja2VyLWVkaXRvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtY29tcG9uZW50cy9zcmMvbGliL3BpY2tlci9waWNrZXItZWRpdG9yL3BpY2tlci1lZGl0b3IuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWNvbXBvbmVudHMvc3JjL2xpYi9waWNrZXIvcGlja2VyLWVkaXRvci9waWNrZXItZWRpdG9yLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQVUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZGLCtEQUErRDtBQUMvRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFPMUQsT0FBTyxFQUFFLE1BQU0sRUFBbUIsTUFBTSxjQUFjLENBQUM7Ozs7O0FBT3ZELE1BQU0sT0FBTyxxQkFBcUI7SUFZaEMsWUFDeUIsTUFBdUI7UUFBdkIsV0FBTSxHQUFOLE1BQU0sQ0FBaUI7UUFSaEQsV0FBTSxHQUFRLEVBQUcsQ0FBQyxDQUFDLDRDQUE0QztRQUVyRCxZQUFPLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQyxDQUFDLDJDQUEyQztRQUcxRSxhQUFRLEdBQVksRUFBRSxDQUFDO0lBR29CLENBQUMsQ0FBQyxHQUFHO0lBQ3ZELDhDQUE4QztJQUVoRCxRQUFRO1FBQ04sTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMxQiw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRS9DLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxjQUFjLENBQUksSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNyRixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0RCx1REFBdUQ7UUFDdkQsdUJBQXVCO0lBQ3pCLENBQUM7SUFFRDs7OztPQUlHO0lBRUgsTUFBTSxDQUFDLElBQU87UUFDWixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNyRSxJQUFJLFFBQVE7WUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7WUFDM0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUTtZQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBSTtRQUNGLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELFNBQVMsQ0FBQyxJQUFPO1FBQ2YsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQsWUFBWSxDQUFDLEtBQWdCO1FBQzNCLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQzdDLGtCQUFrQjtRQUNsQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakMsQ0FBQzs4R0FyRFUscUJBQXFCLGtCQWF0QixNQUFNO2tHQWJMLHFCQUFxQixzSkNoQmxDLHV2Q0ErQkM7OzJGRGZZLHFCQUFxQjtrQkFMakMsU0FBUzsrQkFDRSxtQkFBbUI7OzBCQWlCMUIsTUFBTTsyQkFBQyxNQUFNO3lDQU5OLE9BQU87c0JBQWhCLE1BQU07Z0JBRUUsVUFBVTtzQkFBbEIsS0FBSztnQkFDRyxRQUFRO3NCQUFoQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbi8vaW1wb3J0IHsgUGFnZWRMaXN0IH0gZnJvbSAnc3JjL2FwcC9zaGFyZWQvbW9kZWxzL3BhZ2VkLWxpc3QnO1xyXG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XHJcbi8vIGltcG9ydCB7IFBhZ2VkUmVxdWVzdCB9IGZyb20gJ3NyYy9hcHAvc2hhcmVkL21vZGVscy9wYWdlZC1yZXF1ZXN0JztcclxuLy8gaW1wb3J0IHsgZ2V0UmVxdWVzdCB9IGZyb20gJy4uLy4uLy4uL290aGVyL3V0aWxzJztcclxuaW1wb3J0IHsgUGFnZUV2ZW50IH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvcGFnaW5hdG9yJztcclxuLy9pbXBvcnQgeyBGaWx0ZXJSZXF1ZXN0IH0gZnJvbSAnc3JjL2FwcC9zaGFyZWQvbW9kZWxzL2ZpbHRlci1yZXF1ZXN0JztcclxuaW1wb3J0IHsgUGlja2VyQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL3BpY2tlci1jb25maWcnO1xyXG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICcuLi8uLi8uLi9tb2RlbHMvZW50aXR5JztcclxuaW1wb3J0IHsgRURJVE9SLCBFZGl0b3JDb21wb25lbnQgfSBmcm9tICcuLi8uLi9lZGl0b3InO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdhcHAtcGlja2VyLWVkaXRvcicsXHJcbiAgdGVtcGxhdGVVcmw6ICcuL3BpY2tlci1lZGl0b3IuY29tcG9uZW50Lmh0bWwnLFxyXG4gIHN0eWxlVXJsczogWycuL3BpY2tlci1lZGl0b3IuY29tcG9uZW50LnNjc3MnXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgUGlja2VyRWRpdG9yQ29tcG9uZW50PFQgZXh0ZW5kcyBFbnRpdHk+IGltcGxlbWVudHMgT25Jbml0e1xyXG5cclxuICBjb25maWchOiBQaWNrZXJDb25maWc8VD47XHJcbiAgLy8gVE9ETzogUmVtb3ZlIHNlcnZpY2U/OiBhbnk7XHJcbiAgaXRlbXM/OiBUW107IC8vUGFnZWRMaXN0PFQ+OyAvLyBUT0RPOiBBdm9pZCBwYWdlZGxpc3QsIGFzIGluIHRhYmxlXHJcbiAgcGFyYW1zOiBhbnkgPSB7IH07IC8vIFBhZ2VkUmVxdWVzdDsgLy8gVE9ETzogVVNlIGl0IGZvciBwYWdpbmc/XHJcbiAgc2VsZWN0aW9uITogU2VsZWN0aW9uTW9kZWw8VD47XHJcbiAgQE91dHB1dCgpIGNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vIFRPRE86IFVTZSBpdCB0byB1cGRhdGUgZGF0YSBmcm9tIG91dHNpZGVcclxuXHJcbiAgQElucHV0KCkgdG90YWxJdGVtcz86IG51bWJlcjtcclxuICBASW5wdXQoKSBwYWdlU2l6ZT86IG51bWJlciA9IDEwO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3QoRURJVE9SKSBwdWJsaWMgZWRpdG9yOiBFZGl0b3JDb21wb25lbnQpIHsgfSAvLyxcclxuICAgIC8vIFRPRE8gUkVNT1ZFIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yKSB7IH1cclxuXHJcbiAgbmdPbkluaXQoKTogdm9pZCB7XHJcbiAgICBjb25zdCBkYXRhID0gdGhpcy5lZGl0b3IuY29uZmlnLmRhdGE7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGRhdGEuY29uZmlnO1xyXG4gICAgLy8gdGhpcy5zZXJ2aWNlID0gdGhpcy5pbmplY3Rvci5nZXQ8YW55PihkYXRhLmNvbmZpZy5zZXJ2aWNlKTtcclxuICAgIHRoaXMuZWRpdG9yLnNhdmVkLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNhdmUoKSk7XHJcblxyXG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uTW9kZWw8VD4odHJ1ZSwgdGhpcy5jb25maWcubXVsdGlwbGUgPyBkYXRhLml0ZW1zIDogW10pO1xyXG4gICAgdGhpcy5zZWxlY3Rpb24uaXNTZWxlY3RlZCA9IHRoaXMuaXNDaGVja2VkLmJpbmQodGhpcyk7XHJcbiAgICAvLyBUT0RPIHRoaXMucGFyYW1zID0gZ2V0UmVxdWVzdCh0aGlzLmNvbmZpZz8uZmlsdGVycyk7XHJcbiAgICAvLyBUT0RPIHRoaXMuZ2V0RGF0YSgpO1xyXG4gIH1cclxuXHJcbiAgLypnZXREYXRhKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zZXJ2aWNlLnNlYXJjaCh0aGlzLnBhcmFtcykuc3Vic2NyaWJlKChyZXN1bHQ6IFBhZ2VkTGlzdDxUPikgPT4ge1xyXG4gICAgICB0aGlzLml0ZW1zID0gcmVzdWx0O1xyXG4gICAgfSk7XHJcbiAgfSovXHJcblxyXG4gIHRvZ2dsZShpdGVtOiBUKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLmZpbmQoeCA9PiB4LmlkID09PSBpdGVtLmlkKTtcclxuICAgIGlmIChzZWxlY3RlZCkgdGhpcy5zZWxlY3Rpb24uZGVzZWxlY3Qoc2VsZWN0ZWQpO1xyXG4gICAgZWxzZSB0aGlzLnNlbGVjdGlvbi5zZWxlY3QoaXRlbSk7XHJcbiAgICBpZiAoIXRoaXMuY29uZmlnLm11bHRpcGxlKSB0aGlzLnNhdmUoKTtcclxuICB9XHJcblxyXG4gIHNhdmUoKSB7XHJcbiAgICB0aGlzLmVkaXRvci5jbG9zZSh0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZCk7XHJcbiAgfVxyXG5cclxuICBpc0NoZWNrZWQoaXRlbTogVCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLnNvbWUoeCA9PiB4LmlkID09PSBpdGVtLmlkKTtcclxuICB9XHJcblxyXG4gIG9uUGFnZUNoYW5nZShldmVudDogUGFnZUV2ZW50KSB7XHJcbiAgICB0aGlzLnBhcmFtcy5wYWdlTnVtYmVyID0gZXZlbnQucGFnZUluZGV4ICsgMTtcclxuICAgIC8vIHRoaXMuZ2V0RGF0YSgpO1xyXG4gICAgdGhpcy5jaGFuZ2VkLmVtaXQodGhpcy5wYXJhbXMpO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogRW5hYmxlIGFnYWluXHJcbiAgLypmaWx0ZXIoZmlsdGVyczogRmlsdGVyUmVxdWVzdFtdKSB7XHJcbiAgICB0aGlzLnBhcmFtcy5maWx0ZXJzID0gZmlsdGVycztcclxuICAgIHRoaXMucGFyYW1zLnBhZ2VOdW1iZXIgPSAxO1xyXG4gICAgdGhpcy5nZXREYXRhKCk7XHJcbiAgfSovXHJcbn1cclxuIiwiPCEtLSBGaWx0ZXJzIC0tPlxuPCEtLSAvLyBUT0RPOiBBZGQgZmlsdGVycy4uLiAtLT5cbjwhLS08YXBwLWZpbHRlcnMgKm5nSWY9XCJjb25maWcuZmlsdGVyc1wiIFtmaWx0ZXJzXT1cImNvbmZpZy5maWx0ZXJzXCIgKG9uRmlsdGVyKT1cImZpbHRlcigkZXZlbnQpXCIgLz4tLT5cblxuPCEtLSBTZWxlY3Rpb24gbGlzdCAtLT5cbkBpZiAoaXRlbXM/Lmxlbmd0aCkge1xuICA8bWF0LXNlbGVjdGlvbi1saXN0ICNwaWNrZXIgY2xhc3M9XCJtdC0yXCJcbiAgICBbbXVsdGlwbGVdPVwiY29uZmlnLm11bHRpcGxlXCIgW2hpZGVTaW5nbGVTZWxlY3Rpb25JbmRpY2F0b3JdPVwidHJ1ZVwiPlxuICAgIDwhLS0gLy8gVE9ETzogQ2hlY2sgaWYgdGhlIGNvbmdpZy5pZChpdGVtKSBjb25kaXRpb24gYmVsb3cgaXMgY29ycmVjdCAtLT5cbiAgICBAZm9yIChpdGVtIG9mIGl0ZW1zOyB0cmFjayBpdGVtKSB7XG4gICAgICA8bWF0LWxpc3Qtb3B0aW9uIGNsYXNzPVwibGlzdC1pdGVtXCIgW3ZhbHVlXT1cIml0ZW0uaWRcIlxuICAgICAgICBbc2VsZWN0ZWRdPVwic2VsZWN0aW9uLmlzU2VsZWN0ZWQoaXRlbSlcIiAoY2xpY2spPVwidG9nZ2xlKGl0ZW0pXCI+XG4gICAgICAgIDxzcGFuIG1hdExpc3RJdGVtVGl0bGU+e3sgY29uZmlnLm5hbWUoaXRlbSkgfX08L3NwYW4+XG4gICAgICAgIEBpZiAoY29uZmlnLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgPHNwYW4gbWF0TGlzdEl0ZW1MaW5lPnt7IGNvbmZpZy5kZXNjcmlwdGlvbihpdGVtKSB9fTwvc3Bhbj5cbiAgICAgICAgfVxuICAgICAgPC9tYXQtbGlzdC1vcHRpb24+XG4gICAgfVxuICA8L21hdC1zZWxlY3Rpb24tbGlzdD5cbn0gQGVsc2Uge1xuICA8ZGl2IGNsYXNzPVwiYm9yZGVyIHJvdW5kZWQgcC0zIG10LTNcIj5cbiAgICB7eyAnTmVzc3VuIGVsZW1lbnRvIGRhIHZpc3VhbGl6emFyZScgfX0gPCEtLSAvLyBUT0RPOiBUcmFuc2xhdGUgaW4gd2hvbGUgbGlicmFyeSAtLT5cbiAgPC9kaXY+XG59XG5cblxuPCEtLSBQYWdpbmF0aW9uIC0tPlxuPCEtLSAvLyBUT0RPOiBDaG5hZ2UgcGFnaW5hdGlvbiAtLT5cbkBpZiAoaXRlbXMgJiYgdG90YWxJdGVtcyAmJiBwYWdlU2l6ZSAmJiB0b3RhbEl0ZW1zID4gcGFnZVNpemUpIHtcbiAgPG1hdC1wYWdpbmF0b3IgW2xlbmd0aF09XCJ0b3RhbEl0ZW1zXCJcbiAgICBbcGFnZVNpemVdPVwicGFnZVNpemVcIiBbaGlkZVBhZ2VTaXplXT1cInRydWVcIiAocGFnZSk9XCJvblBhZ2VDaGFuZ2UoJGV2ZW50KVwiIHNob3dGaXJzdExhc3RCdXR0b25zIC8+XG59Il19